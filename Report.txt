Name:Tavita Afata 

Number of elements: 8000

Bubble Sort
Sorted: 1.50643 seconds
Reversed: 3.57277 seconds
Random: 2.68655 seconds

Bubble Sort Early Exit
Sorted:0.00068 seconds
Reversed:3.80564 seconds
Random:2.75729 seconds

Selection Sort
Sorted: 1.24827 seconds
Reversed:1.22563 seconds
Random:1.20225 seconds

Insertion Sort
Sorted: 0.00074 seconds
Reversed: 2.55414 seconds
Random: 1.16281 seconds

Merge Sort
Sorted:0.03380 seconds
Reversed:0.02728 seconds
Random:0.04132 seconds

Questions to answer:
1) What was the worst case scenario for any sorting technique?
Bubble sort early exit reversed list took a longer time to appear but also just all the sorts took a bit longer to load their reversed list. 

2) The first 3 sorts have the same runtime of O(n^2). Why were the times different? Why would one be more efficient than the others?
The first three sorts have different times because the amount of work being done or the type of operations they perform might be different. 

3) Why was merge sort so much more efficient?
Merge sort is efficient because it breaks down larger tasks into smaller, manageable ones and requires less work than the others.

4) The built-in sorting technique for most programming languages is known as TimSort.
This is a merge sort until the arrays have fewer than 10 elements, then it does an insertion sort. Why would this be useful?
TimSort is useful because it combines the strength of two different sorts. Merge sort splits large data into tiny parts.

5) What issues can you see with a recursive sorting technique like merge sort?
It handles large data so it needs a huge amount of memory space and it would be harder to track because of the jumbling that goes on when it is divided and sorted.